# Инструкция

## Подготовка сервера
Для работы требуется Nginx, PHP-FPM и composer.

В Ubuntu их можно разом установить так:
```
sudo add-apt-repository ppa:ondrej/php
sudo apt install nginx php7.2-fpm php7.2-opcache php-xml php-yaml php-mbstring php-dev libevent-dev php-pear composer make php-curl php-pgsql
sudo pecl install event 
echo 'extension=event.so' | sudo tee -a /etc/php/7.2/cli/conf.d/20-event.ini
echo "extension=event.so" | sudo tee -a /etc/php/7.2/fpm/conf.d/20-event.ini
```

Установим NPM и Yarn:
```
curl -sL https://deb.nodesource.com/setup_8.x | sudo bash -
sudo apt-get install -y nodejs
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -
echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list
sudo apt-get update && sudo apt-get install npm yarn
```

Установим глобальные утилиты:
```
sudo yarn global add browserify watchify minifyjs prettier
sudo npm install -g uglifyify
```

Также для удобства работы в bash рекомендуется выполнить `cat .bash_profile >> ~/.bash_profile` и затем `bash`. 

## Сборка проекта

Сценарий построен с использованием на GNU Make 4+ (он же `make`).
 
### Этапы
* all: `packages fmt routes build test`
* fmt
    * fmt-php — отформатировать PHP-код
    * fmt-js — отформатировать код Javascript
    * fmt-css — отформатировавать CSS
* packages
    * packages-composer — установка пакетов через composer (composer.json)
    * packages-yarn — установка пакетов через yarn (packages.json)
* routes — генерация конфигурационного файла Nginx и файла Routes.cfg.js
* build — запустить сборку бандлов с помощью npm в зависимости от ENV.
* migrate — накатить миграции
* test — выполнить тесты 
* clean — удалить все созданные в процессе сборки файлы/папки

### Переменные
* ENV (значения _dev_, _prod_, _stage_) — содержит название текущей среды.


### Примеры
 
Запустить сборку в окружении для разработчика можно так:  `make ENV=dev`

Чтобы запустить автоматическую пересборку JS и CSS при изменении файлов: `BUNDLE=main npm run watch`,
где переменная `BUNDLE` означает название бандла (`main`, `admin`, ...).

Чтобы запустить production-сборку: `make ENV=prod`


### Настройка NGINX

Необходимо добавить nginx/server.conf в sites-enabled: 

`ln -s <КОРЕНЬ ПРОЕКТА>/nginx/server.conf /etc/nginx/sites-enabled/001-site.conf`

При необходимости подправив в нём конфигурацию upstream fpm. И перезапустить NGINX.

 
# Философия
<i>Данный раздел можно пропустить, но он рекомендуется разработчикам к прочтению.</i>

Фреймворк исполнен минимализма и создан по трём базовым принципам — 
 элегантность, производительность, прагматизм.


### Производительность

PHP 7 замечательный язык с достойноной производительностью, но разработчики популярных фреймворков
так увлеклись подменяемостью и универсальностью, попутно добавляя всё больше runtime-абстракций,
что не заметили как перевернули всё с ног на голову. Зачастую можно видеть, что есть обширный Registry модулей,
которые при каждом запросе перебираются поочередно и каждый что-то вносит в состояние. 

В результате имеем то что имеем. Среднестатический сайт выдерживает от силы 50 запросов
в секунду (без кеширования ответов в nginx) на выделенном сервере занимающем пару юнитов в стойке.    


#### Принцип нулевого бутстрапа  
Это backtrace из _Hello world!_ контроллера, просто сравните его с вереницей вызовов в тех фреймворках,
которые вам доводилось использовать. Вы будете удивлены.
  
    1	0.0000	397392	{main}( )	.../index.php:0
    2	0.0006	444616	Zer0\HTTP\HTTP->handleRequest( )	.../index.php:22
    3	0.0008	520416	Signal\HTTP\Controllers\Index->indexAction( )	.../HTTP.php:136

Мы не делаем лишних действий в runtime и не выполняем код без требования.

Например, у нас считается моветоном обращаться к сессии (считывать её из хранилища), если того не требует бизнес-логика
выполнения данного конкретного HTTP-запроса. Равно как и обращаться к хранилищу сессий на запись,
если в данных сессии не было изменений.

Composer реализован так, что подключенные зависимости могут бесстыдно добавлять файлы в безусловную автозагрузку,
поэтому в папке cli отдельный composer.json для таких пакетов как phinx, которые не используются в веб-части.
В cli производительность не играет никакой роли и там нет проблемы подключать всё что угодно,
а основное приложение мы содержим в чистоте.


#### PHP больше не рождён умирать
Исторически PHP воспринимался как интерпретатор, который полностью сбрасывает своё состояние после
завершения обработки запроса. Однако, намного более производительным вариантом является истинный FastCGI,
когда bootstrap-фаза в рабочем процессе выполняется единожды и затем идёт последовательная обработка входящих запросов.
Отсюда и приставка Fast в FastCGI. Классический же CGI лишён возможности проводить bootstrap-фазу единожды.  

* Мы не используем exit() и die()
* Вместо Fatal error мы пользуемся исключениями.
* Константы не должны быть запросозависимыми. 


#### Близость к PHP
В большинстве фреймворков (не будем тыкать пальцем), для обращения к параметру запроса  несколько десятков классов,
создать легион объектов и потом вызвать метод, который вызовет метод, который вызовет метод, который обратится к коллекции параметров запроса,
 проверит есть ли параметр и вернет значение или параметр _$default_. Это очень непроизводительность, неинтуитивно и громоздко
 
Мы пишем просто `$_GET['name'] ?? 'John Doe'`.
Да, когда-то не было оператора _??_ и приходилось либо тащить везде _isset()_ либо использовать методы-хелперы.
Но те времена канули в лету. 

#### Тесты
Unit и интеграционные тесты — это замечательно. Чем больше кода покрыто тестами, тем меньше шансов что-то сломать и не заметить.
Однако, тесты должны быть быстрыми, а главное поддерживаешь многопоточное выполнение. 

### Прагматизм
#### Отношение к версиям PHP
Мы всегда ориентируемся на последнюю стабильную версию PHP (в данный момент это _7.2.10_), поддержке 
более старых версий внимание не уделяется, так мы можем использовать последние новинки и при этом обойтись
без условий с _PHP_VERSION_.

#### Code Style
Мы не тратим драгоценное время на то чтобы поддерживать стиль кода вручную, а также на споры о том какой
стиль лучше.

> Команда `make fmt` (цель `fmt` также включена в `all`) в 
dev-окружении автоматически форматирует все PHP, JS и CSS исходники.

#### Типизация
При разработке фреймворка мы почти во всех случаях придерживаемся принципа строгой типизации.
То бишь у функций/методов должен быть задан тип аргументов, а также тип возвращаемого значения.
Например,

`public function validate(?string $token = null): bool`

Это позволяет избежать множества багов. Также крайне желательно указывать `declare(strict_types=1);`
в начале каждого файла.

Мы не используем `loose comparison` (операторы `==` и `!=`) почти никогда. Редкое исключение — когда нужно сравнить два объекта
по типу и свойствам, а не по ссылке.

Также мы не приводим строки к boolean, float и integer по причине некорректного отождествления, которое сложилось в PHP
исторически. Так,

    php > var_dump(('1helloWorld' == 1);
    bool(true)

Что может вести к нехорошим последствиям при обработке пользовательского ввода.


## Брокеры
По своей сути они являются фабриками компонентов и библиотек.
Например, `$app->broker('Redis')->get()` вернет объект драйвера Redis с настройками взятыми из `conf/Redis`.
Метод get() принимает необязательный параметр с именем конфигурации, что позволяет иметь несколько конфигураций
одного компонента.

Есть брокеры, которые хранят объект после первого создания, например, `PDO` или `SessionStorage`. Другие же, такие как `Session`, 
при каждом вызове `get()` порождают новый объект.

#### Добавление собственного брокера

В конфигурацию Main нужно добавить:
```
brokers:
  MyCustomBroker: \My\Custom\Broker
```

И создать соответующий класс наследующийся \Zer0\Brokers\Base.

Таким же образом можно подменить и брокеры, которые лежат в `\Zer0\Brokers\*` и не нуждаются в объявлении в конфиге.


## Компоненты

### HTTP

#### Контроллеры
Контроллеры лежат в `\*\Controllers\` (наследуются от `\Zer0\HTTP\AbstractController`).
Чтобы создать контроллер достаточно создать класс с одним или несколькими публичными методами `*Action`,
а также добавить пути указывающие на него в conf/Routes.

Перед выполнением любого `*Action` происходит вызов `before()`, после — `after()`, в них принято выносить общие операции,
такие как проверка авторизации пользователя. 

Методы `*Action` могут возвращать экземпляр `\Zer0\HTTP\Responses\*`, в против случае если возвратное значение не null, то оно будет
выведено в формате JSON (`\Zer0\HTTP\Responses\JSON`). Это поведение может быть переопределено в методе `renderResponse()` контроллера.


#### Конфигурирование роутов
Формат следующий:

````
getting_started:
    path:     /getting-started/{action}
    defaults: {controller: GettingStarted, action: intro}
    methods: [GET, POST]
    export: [JS] 
...
````

 * path — путь данного роута, допускаются параметры (переменные) в фигурных скобках.
 * path_export — необязательный путь, который будет вместо _path_ при составлении URL. Удобно при использовании CDN.
 * defaults — необязательный набор значений по-умолчанию.
 * methods — необязательный список допустимых методов.
 * export — необязательный список того, куда экспортировать данный роут.
 * sort — необязательный параметр, по которому происходит сортировка, по-умолчанию 0.
 Чем меньше значение, тем раньше он будет выполнен.
 
Если action не задан, то присваивается значение index.
Controller обязан быть задан чтобы запросы могли выполняться.

Класс `\Zer0\HTTP` (`$this->http`) имеет метод

`public function buildUrl(string $routeName, $params = [], array $query = []): string`

позволяющий построить URL, например так: `$this->http->buildUrl('getting_started', 'routes', ['foo' => 'bar']);`
При конфигурации роута `getting_started` как в примере выше результатом будет `/getting-started/routes?foo=bar`

Также можно пользоваться аналогичной функцией в Javascript — `Routes.url()`. При этом доступны только те роуты, 
у которых в списке export есть JS. 

Жестко указывать URL в коде не рекомендуется. 

*Внимание!* Учтите, что после внесение изменений в конфигурацию роутов необходимо выполнить `make routes`

### Cli

Интерфейс командной строки.
```
$ cli help
```` 

### Quicky
В качестве шаблонизатора по-умолчанию используется Quicky.
[Документация](https://htmlpreview.github.io/?https://github.com/kakserpom/quicky/blob/master/_doc/doc.html).

Конфигурация описана там же.
 
### Сессии

Мы используем собственный транзакционный механизм сессий, избавленный от блокировок и постоянного чтения-записи,
которым отличается встроенный в PHP механизм сессий.

Чтобы стартовать сессию нужно вызвать:

```php
$session = $app->broker('Session')->get();
$session->start(); /* или */ $session->startIfExists();
```
    
`start()` стартует сессию безусловно, а `startIfExists()` только если она уже была начата ранее.
Если вы не планируете писать в сессию, используйте `startIfExists()`.
Эти вызовы можно делать многократно — ошибки это не вызовет.

Дальше вы можете работать с `$_SESSION` (`=== $session`) как обычно. Вы также можете использовать
`$_SESSION->incr('someKey')` для атомарной работы со счетчиками.

Сессия автоматически пишется в конце запроса, но вы также можете вызвать `write()`, `regenerateId()`, `destroy()`
 и другие методы.

Для краткости в контроллере есть хелперы в виде методов `sessionStart()` и `sessionStartIfExists()`.

> В сессии не рекомендуется хранить большие объекты, рекомендуется ограничиться скалярными значениями.
Например, лучше хранить ключ UID вместо сериализованного объекта User. Объект User следует кешировать отдельно с помощью
компонента Cache.


### Cache
Компонент служит для кеширования.

#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|type|string| Тип хранилища |Redis

#### Пример использования
    
```php
$pool = $this->app->broker('CachePool')->get();
$user = $pool->item('user.' . $userId)->setCallback(function (Item $item) use ($userId) {
  $item
  ->expiresAfter(60 * 60 * 24)
  ->set(getUserFromDatabase($userId))
  ->save();
})->get();
```

### Queue
Компонент реализует очереди.

#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|type|string| Тип хранилища |Redis

#### Пример использования
    
```php
$pool = $this->app->broker('Queue')->get();
try {
    var_dump($pool->enqueueWait(new SomeTask(), /* ждём ответа */ 3 /* секунды */)->foo);
    // string(3) "bar"
} catch (\Zer0\Queue\Exceptions\WaitTimeoutException $e) {
    // Задача не завершилась за 3 секунды
}
```

Так выглядит SomeTask:

```php
final class SomeTask extends \Zer0\Queue\TaskAbstract
{
    /**
     * @var string
     */
    public $foo;
    
    /**
     *
     */
    public function execute(): void
    {
        $this->foo = 'bar';

        $this->complete();
    }
}
```


### PubSub
Компонент реализует PubSub-сервис, используемый для рассылки сообщений (событий) по каналам. 

#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|type|string| Тип хранилища |Redis

#### Пример использования
   
##### Рассылка
```php
$pubsub = $this->app->broker('PubSub')->get();
$pubsub->publish(new \Zer0\PubSub\Message('someChannel', 'Hello world!'));
```

##### Подписка (асинхронный вариант)

```php
$pubsub = $this->app->broker('PubSubAsync')->get();

// Подписка на определенный канал
$pubsub->subscribe('someChannel', function ($payload, string $chan) {
    var_dump($payload);
   // string(12) "Hello world!"
});

// Подписка по шаблону
$pubsub->psubscribe('some*', function ($payload, string $chan) {
   var_dump($payload);
   // string(12) "Hello world!"
});
```

 

### CSRF_Token
Криптографические CSRF-токены.

#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|secret|string| Секретный ключ, псевдослучайная строка|\*\*SECRET\*\*|
 
### Tracy
Для отладки мы используем [Tracy](https://tracy.nette.org).

#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|secret|string| Пароль|changeme|
|mode|string| on/mode/auth |off|

Если параметр `mode` равен `on`, отладочная информация отображается всегда.
При `off` никогда. При `auth` отладка включается при передаче в запросе параметра `tracy-debug`
равного параметру `secret`. Режим `auth` рекомендуется к использованию в production.
   

*Внимание!* Рекомендуется изменить secret перед использованием проекта в production.
 

### Redis
Брокер для [php-redis-client](https://github.com/cheprasov/php-redis-client).

  
#### Конфигурация
|Имя|     Тип|       Описание| Значение по-умолчанию|
|:-------:|:---:|:--------------:|:---------------------:|
|server|string| Адрес сервера |127.0.0.1|
|port|int| Порт сервер |6379|

#### Пример использования: 

```php
$redis = $app->broker('Redis')->get();
$redis->set('foo', 'bar');
```

### PDO

### Socket 


 
# ЧаВО

#### Почему роутинг осуществляется в Nginx?

 Такой подход имеет ряд преимуществ:
1. Количество роутов не влияет на производительность, так как Nginx
  не идёт перебором по списку роутов, как роутеры запросов, написанные на PHP, а используя Btree+ индекс
 по заякоренной части за _O(log n)_ находит подходящие location'ы.
2. Разные роуты можно при желании направить на разные пулы PHP-FPM и не составляет труда добавить, например, limit_req.
3. PHP-части даже не нужно читать и держать в памяти конфигурацию роутов.





